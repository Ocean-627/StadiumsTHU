## 后端部分

说明：项目后端定义了场馆场地等资源，实现了用户、管理员进行各项操作等需要的逻辑，特别的，本项目中的大多数控制层在后端。

实现概述：使用`django​`框架，为了应对高并发并保证安全性，使用`​mysql​`数据库。

##### 数据表定义

共20类，主要划分为实体对象类和事件类。

实体对象类：

```python
class User			用户
class Manager		管理员
class Stadium		场馆
class CourtType		运动时段安排
class Court			场地
class Duration		时段
class Comment		评论
class StadiumImage	场馆图片
class CommentImage	评论图片
```

它们之间存在一些一对多关系，如场地与场馆，在数据表中由外键实现。定义图片类的原因`django​`是关系型数据库，无法存储列表。

事件类：

```python
class ReserveEvent	预订事件
class CollectEvent	收藏事件
class Default		违约记录
class ChangeDuration修改预约时段事件
class AddEvent		添加场馆占用
class AddBlacklist	添加黑名单
class OtherOperation其他操作
class Session		会话
class Message		聊天消息
class New			系统信息
class Statistics	统计信息
```

##### 业务逻辑实现

依照`restfulAP​`规范中的面向资源编程，`url`的名称均为一种资源，可以是实体资源也可以是事件。并为增删改查对应实现`post,get,put,delete​`方法。

具体实现中结合了很多`restful_framework​`定义的工具类：

视图层次上主要基于`APIView,ListAPIView,CreateAPIView`

身份认证：基于`BaseAuthentication​`

序列化：基于`ModelSerializer,Serializer​`

筛选、查找：基于`FilterSet​`

访问频率控制：基于`SimpleRateThrottle​`

另外还定义了`validator,pagination,exception​`等模块。

基于以上这些工具类，很多接口可以非常简洁的实现，以用户的`CourtView`为例，其视图函数定义如下：

```python
class CourtView(ListAPIView):
    """
    场地信息
    """
    authentication_classes = [UserAuthtication]
    throttle_classes = [UserThrottle]
    queryset = Court.objects.all()
    serializer_class = CourtSerializer
    filter_class = CourtFilter
```

该视图函数自动的完成以下功能，在用户发送请求时首先验证身份，并判断是否超过访问频率。而后在`queryset`中根据一些筛选规则查询，最后由序列化器返回。

`django`框架也为这样的视图提供了很大的扩展性，通过重写一些钩子函数如`get_queryset`即可实现自定义的处理逻辑。

##### 实现难点

由于用户和管理员使用同样的数据表，存在本质的耦合关系，所以后端实现的难点之一就是如何解耦各种资源，另外解耦的过程中也受到框架的限制。

另一方面，事件信息自然是与资源耦合的，比如添加新场地，根据针对资源编程的原则其`url`是`/api/user/stadium/`，方法为`post`，但是其会产生一个添加新场地的事件，这个事件的创建不得不由该视图函数来完成。

最后，前端的展示需求往往是耦合的，为了保证用户良好的操作体验，在编辑场馆的时候可能需要提示场地的信息。另外前端的一些组件存在渲染上的问题，限制了获取某些信息必须使用一个接口。

以上是比较宏观的描述，具体来说管理员端的很多操作本身就涉及非常复杂的逻辑，如添加场地占用，我们实现了系统智能搜索，这需要遍历时段找到符合要求的连续时段，我们实现了强制占用，即占用某些用户已经预约的场地，这就产生了一连串问题——需要给用户发送提示，需要更改场地的状态，需要改变用户预约记录的状态。另外我们还支持对部分操作的撤销。

##### 实现优势

从功能上：实现了复杂的操作逻辑，通过了测试。实现的功能非常齐全。

架构上有以下优势：视图函数解耦了操作的几个层次，很好的对实现进行了模块化。

扩展性比较好，对于`get`请求非常容易返回更多字段给前端，尚未实现的一些模块和当前框架耦合不大，比如实现抽签功能时只需要为管理员端写一个抽签算法，稍微修改预订状态即可完成。

进行了完备的参数检查，包括类型、格式、合法性检查，自定义错误返回结果并修改返回状态码，前端可以通过`status_code`进行拦截，区分。

绝大多数函数的效率很高，没有使用繁杂的多重循环。

**实现不足**

`restfulAPI`的固有缺陷，返回太多无用数据，降低了效率，同时增加了前端的工作负荷。

`duration`类的定义不够合理，这个类的用意为将一天的时间根据最短预订时间划分为若干个单元格，用户在预订时实际上是选择其中的一些单元格，这样简化了前端的操作。但实际结果发现其导致了很大的弊端，很多资源关于`duration`产生了耦合。并且该问题发现比较晚，难以进行修改。

`serializer`类承担的任务过重，除了验证字段和序列化资源的基本用法，还额外承担了创建事件的任务。这些代码应该移入视图函数中，而不是定义在序列化类中。

存在一定的效率缺陷，极少数查询结果涉及关于外键内容的二次查询。

## 测试部分

在本任务的开发过程中，进行了对于后端的单元测试，性能测试，以及模块组合后的系统测试，前后端结合后的测试等等，以下分别介绍。

##### 后端部分

主要进行了单元测试、性能测试、回归测试

单元测试：工具为`Postman`和`django`内置的`TestCase`。测试文件在在`app/test`目录下。

主要的切入点是各个视图函数，对于每个`url`对应的增删改查操作进行测试，保证其基本逻辑正确。例如在测试预订时，首先测试预订非法输入能否返回错误，合法预订能否成功，再次预订同一时段能否成功，撤销后状态是否发生变化等等一系列逻辑。该测试覆盖了所有`url`。

进行了上述所说的对单个`url`测试后，我们还组合了一些`url`进行测试，尤其是管理员部分复杂的逻辑，根据`28`原则，我们认为这些部分有更高的概率出现`bug`。进行组合测试的原则是覆盖用户使用的基本流程，比如在添加场馆时要首先添加场馆，然后编辑这个场馆的场地，而后可能进行修改等等。

单元测试的时间和简要目的在各个测试文件中，这里就不列举了。

性能测试：基于`Jmeter`，主要测试了速度和稳定性。测试中发现一个巨大问题是mysql的并发数，更改为2000后明显好转。速度方面，主要对各种`get`接口进行测试，访问`localhost`时大多数端口的时延在$2.5s-3.5s$，猜测是访问远程数据库降低了效率，部署后再次测试降低到$1s-2s$，达到可接受范围。稳定性方面，分别进行了500路并发和1500路并发实验，500路并发时稳定没有错误，1500路并发20轮测试时，前1-2轮有10%-20%的错误，但从第三轮开始稳定没有错误，不会出现两个用户同时预订一个场馆时同时获得的情况。实际使用时小程序体感延迟很低，应该在$1s$以下，网页端有约$1s-2s$的延迟。

回归测试：做的工作是添加新的功能后重新测试之前已经实现好的功能，结果非常好，及时的找出了`bug`，并且其还有一个隐含的作用，如果发现之前的测试几乎不需要改动，那么证明程序解耦做的比较好。

##### 前后端结合部分

相当于测试最终的项目表现，主要进行人工测试，方法为一个前端人员和一个后端人员一起测试，首先测试所有页面的所有功能。而后原则是模拟用户操作的各个流程，确保流程没有问题，例如在小程序端进行了用户预订的全部流程，在网页端测试了管理员添加场馆的过程等。

